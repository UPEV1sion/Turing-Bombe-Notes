\chapter{Implementierung}\label{ch:impl}
%\section{Enigma-Maschine}\label{sec:impl_enigma}
%Um die Bombe in Software Nachzubilden, muss zuerst eine Enigma-Maschine nachgebildet werden.
%\subsection{Rotoren}\label{subsec:impl_enigma_rotor}
%Die Verdrahtung der Rotoren wurden als Vektor realisiert.
%Der zu permutierende Buchstabe wird hierfür als Index in den Vektor genutzt.


\section{Turing-Welchman-Bombe}\label{sec:impl_bombe}
%\section{Algorithmus Bombe}\label{sec:algorithmus-bombe}
%
%\begin{algorithm}[htbp]
%	\caption{Bombe Algorithmus}
%	\begin{algorithmic}
	%		\Procedure{Bombe}{$p_0 \dots p_{n-1} :$ [Char], $c_0 \dots c_{n-1} :$ [Char]}
	%		\ForAll{\textsl{rotors} $\in$ \textbf{permut(rotor order)}, \textsl{pos} $\in$ \textbf{[AAA $\dots$ ZZZ]}}
	%		\State plugs: Char $\rightarrow \{ $Char$\}$
	%		\State plugs$(p_0)\ \cup= \{\textbf{'A'}\}$
	%		\While{\textsl{plugs} changing}
	%		\ForAll{\textsl{i} $\in$ \textbf{[0\dots n--1]}}
	%		\State plugs($c_i$) $\cup=$ $\bigcup_{p \in \text{plugs}(p_i)}$ encrypt(\textsl{rotors, p, pos}+\textsl{i})
	%		\State plugs($p_i$) $\cup=$ $\bigcup_{p \in \text{plugs}(c_i)}$ encrypt(\textsl{rotors, p, pos}+\textsl{i})
	%		\EndFor
	%		\EndWhile
	%		\If{$\forall$ \textsl{S} $\in$ \textbf{cod(plugs)}: \#S < \#Char}
	%		\State report(\textsl{pos, plugs})
	%		\EndIf
	%		\EndFor
	%		\EndProcedure
	%	\end{algorithmic}
%	\label{alg:algorithm}1
%\end{algorithm}
%
\subsection{Menü Algorithmus}\label{subsec:cycle-finding-algorithm}
Um eine Turing-Welchman-Bombe in der Programmiersprache C nachzubilden, muss zuerst ein Algorithmus entworfen werden, welcher das Menü durch ein von dem Nutzer vorgegebenes Crib und 
%TODO
Geheimtext bildet.

Hierfür werden die Knoten als Struktur dargestellt, welche zum einen den Buchstaben und zum anderen einen Vektor mit den anliegenden Auslegern beinhaltet. 
Die Buchstaben-Tupel wurden ebenfalls als Struktur dargestellt, welche zwei Knoten, die Position im Crib und einen Booleschen Wert beinhaltet welcher aussagt, ob dieses Tupel zum Zyklus beiträgt.


%\section{Software Implementierung}\label{sec:implementierung_bombe}

\noindent
\lstinputlisting[style=mystyle, caption={Realisierung der Menü Strukturen}, label={code:impl_menu}]{Implementierung/menu_structs.c}
Die Tupel werden nun in einer \glqq Nachschlagetabelle\grqq{} abgelegt.
Diese Tabelle hat 26 Stellen, repräsentativ für das Alphabet.
Ein jeweiliges Tupel wird sowohl unter dem erstem als auch unter dem zweiten Buchstabe abgelegt. 
Ein Tupel wie \texttt{W:S} ist also sowohl unter \texttt{W} als auch unter \texttt{S} abgelegt.
Ein Tiefensuche Algorithmus, der modifiziert wurde, um weniger \glqq gierig\grqq{} zu agieren, schlägt nun die Tupel in der Tabelle nach und markiert die besuchten Tupel.
%Bei dem Rücksetzverfahren der Tiefensuche wird die Markierung der Tupel, die nicht zum Zyklus beitragen entfernt.
Das Ergebnis ist eine gemessene, lineare Laufzeit.\footnote{Es wurden Crib-Längen bis 26 betrachtet, um zu garantieren, dass die lineare Laufzeit bei einer maximalen Länge von 13 Buchstaben gegeben ist. Der Laufzeit Graph ist im Anhang enthalten\cref{app:menu_runtime}} 

Das Menü wird als Vektor von \glqq CribCipherTuple\grqq{} in einer Struktur mit der Länge abgelegt.
Da es erforderlich ist, eine eindeutige \glqq Route\grqq{} durch das Menü anzugeben, werden Tupel-Kombination bei den betroffenen Knoten als Ausleger angegeben. 
Die Bombe kann somit im Falle der \glqq Scramblersatz-Knappheit\grqq{} entscheiden, ob sie diesen (nicht notwendigen) Bestandteil des Menüs aufnehmen möchte.

\subsection{Scrambler}\label{subsec:impl_scrambler}
Wie in~\cref{subsec:vorbereitungen} erklärt, vernachlässigt die Bombe den Übertragzeitpunkt der Walzen.
Es muss also nicht Position der Übertragskerbe mitgeführt werden.
%Enigma Software gegeben erwähnen?
Die Verdrahtung der Scrambler wird als Vektor abgebildet, welcher wie in~\cref{fig:rot1_wiring} die Permutation für jeden Buchstaben speichert.
Die Buchstaben werden jedoch nicht in der typischen ASCII-Kodierung gespeichert, sondern auf den Wertebereich 0-25 abgebildet.
Mit dem Resultat kann somit direkt der Vektor des nächsten Scramblers indiziert werden.
Es muss zudem die Walzenlage mitgeführt werden, welche mit dem zu permutierenden Buchstaben addiert wird, um den den Vektor-Index zu bilden.
Der Wertebereich wird durch eine Modulo-Operation zwischen 0 und 25 gehalten.

\subsection{Terminal}\label{subsec:impl_terminal}


\subsection{In und Outs}\label{subsec:impl_in_und_outs}
\subsection{Diagonalbrett}\label{subsec:impl_diagonal_board}
\subsection{Commons}\label{subsec:impl_commons}
Aufgrund der Einfachheit wurden die Commons in dieser Software-Implementation \glqq weg abstrahiert\grqq. 
Diese wurden durch Zeiger auf den gleichen Kontakt ersetzt.
Die Anzahl der Kontakte pro Commons und die Gesamtzahl der verwendeten Commons wurde gezählt, sodass diese nicht die Anzahl des analogen Originals überschreiten.
\subsection{Test-Register}\label{subsec:impl_test-register}

\chapter{Geschwindigkeit der Software-Nachbildung im Kontext}