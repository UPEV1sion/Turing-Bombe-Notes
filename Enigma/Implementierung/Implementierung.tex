\chapter{Implementierung der Turing-Welchman-Bombe}\label{ch:impl_bombe}
%\section{Enigma-Maschine}\label{sec:impl_enigma}
%Um die Bombe in Software Nachzubilden, muss zuerst eine Enigma-Maschine nachgebildet werden.
%\subsection{Rotoren}\label{subsec:impl_enigma_rotor}
%Die Verdrahtung der Rotoren wurden als Vektor realisiert.
%Der zu permutierende Buchstabe wird hierfür als Index in den Vektor genutzt.


%\section{Turing-Welchman-Bombe}\label{sec:impl_bombe}
%\section{Algorithmus Bombe}\label{sec:algorithmus-bombe}
%
\section{Menü Algorithmus}\label{sec:cycle-finding-algorithm}
Um eine Turing-Welchman-Bombe in der Programmiersprache C nachzubilden, muss zuerst ein Algorithmus entworfen werden, welcher das Menü durch ein von dem Nutzer vorgegebenes Crib und 
%TODO
Geheimtext bildet.

Hierfür werden die Knoten als Struktur dargestellt, welche zum einen den Buchstaben und zum anderen einen Vektor mit den anliegenden Auslegern beinhaltet. 
Die Buchstaben-Tupel wurden ebenfalls als Struktur dargestellt, welche zwei Knoten, die Position im Crib und einen Booleschen Wert beinhaltet welcher aussagt, ob dieses Tupel zum Zyklus beiträgt.


%\section{Software Implementierung}\label{sec:implementierung_bombe}

\noindent
\lstinputlisting[style=mystyle, caption={Realisierung der Menü Strukturen}, label={lst:code_impl_menu}]{Implementierung/menu_structs.c}
Die Tupel werden nun in einer \glqq Nachschlagetabelle\grqq{} abgelegt.
Diese Tabelle hat 26 Stellen, repräsentativ für das Alphabet.
Ein jeweiliges Tupel wird sowohl unter dem ersten als auch unter dem zweiten Buchstaben abgelegt. 
Ein Tupel wie \texttt{W:S} ist also sowohl unter \texttt{W} als auch unter \texttt{S} abgelegt.
Ein Tiefensuche-Algorithmus, der modifiziert wurde, um weniger \glqq gierig\grqq{} zu agieren, schlägt die Tupel in der Tabelle nach und markiert die besuchten Tupel.
%Bei dem Rücksetzverfahren der Tiefensuche wird die Markierung der Tupel, die nicht zum Zyklus beitragen entfernt.
Das Ergebnis ist eine gemessene, lineare Laufzeit.\footnote{Es wurden Crib-Längen bis 26 betrachtet, um zu garantieren, dass die lineare Laufzeit bei einer maximalen Länge von 13 Buchstaben gegeben ist.
Der Laufzeit Graph ist im Anhang enthalten:~\cref{fig:app_menu_runtime}}

Das Menü wird als Vektor von \glqq CribCipherTuple\grqq{} in einer Struktur mit der Länge abgelegt.
Da es erforderlich ist, eine eindeutige \glqq Route\grqq{} durch das Menü anzugeben, werden Tupel-Kombination bei den betroffenen Knoten als Ausleger angegeben. 
Die Bombe kann somit im Falle der \glqq Scramblersatz-Knappheit\grqq{} entscheiden, ob sie diesen (nicht notwendigen) Bestandteil des Menüs aufnehmen möchte.

\section{Modellierung der Turing-Welchman-Bombe}\label{sec:model}
\subsection{Scrambler}\label{subsec:impl_scrambler}
Wie in~\cref{subsec:vorbereitungen} erklärt, vernachlässigt die Bombe den Übertragzeitpunkt der Walzen.
Die Software Implementation berücksichtigt ebenfalls die Übertragskerbe der Rotoren nicht.
%TODO Enigma Software gegeben erwähnen?
Die Verdrahtung der Scrambler wird als Vektor abgebildet, welcher wie in~\cref{fig:rot1_wiring} die Permutation für jeden Buchstaben speichert.
Die Buchstaben werden jedoch nicht in der typischen ASCII-Kodierung gespeichert, sondern auf den Wertebereich 0--25 abgebildet.
Mit dem Resultat kann somit direkt der Vektor des nächsten Scramblers indiziert werden.
Es muss zudem die Walzenlage mitgeführt werden, welche mit dem zu permutierenden Buchstaben addiert wird, um den Vektor-Index zu bilden.
Der Wertebereich wird durch eine Modulo-Operation zwischen 0 und 25 gehalten.

\subsection{Terminal}\label{subsec:impl_terminal}
Die Kontakte der Terminals werden Struktur dargestellt.
Es beinhaltet einen 32 Bit Integer, welcher mit 26 Stellen als Bitvektor die aktiven Kontakte repräsentiert.
Die Anzahl der aktiven Kontakte werden ebenfalls als Integer mitgeführt.
Da es im Bezug auf die Laufzeit medioker ist, alle 26 Stellen des Bitvektors traversieren zu müssen, um zu überprüfen welche der 26 aktiv ist, wurde ein normaler Vektor eingeführt, welcher die aktiven Kontakte \glqq dicht\grqq{} speichert. 
%TODO Artikel vor Nummer
Zuletzt wird der Buchstabe/Nummer des jeweiligen Kontakts in der Struktur gespeichert.

\noindent
\lstinputlisting[style=mystyle, caption={Realisierung der Terminals}, label={lst:code_impl_terminal}]{Implementierung/terminal.c}

Permutiert ein Scrambler einen Buchstaben, wird mit dem Bitvektor überprüft, ob dieser Kontakt bereits aktiv ist.

Hierbei gibt es zwei Szenarien:
\begin{enumerate}
	\item Der Kontakt ist inaktiv: In dem Bitvektor wird die repräsentative Stelle aktiviert, der Buchstabe in dem normalen Integer Vektor gespeichert und die Anzahl der Aktiven Verbindungen inkrementiert.
	
	\item Der Kontakt ist aktiv: Dieser Buchstabe wird ignoriert. 
\end{enumerate}

Die Terminal Struktur beinhaltet einen Vektor mit 26 Kontakten und einen Zeiger auf den Kontakt des Test-Registers.
Bei dem Test-Register wird hierbei nicht von einem \glqq normalen\grqq{} Kontakt unterschieden.

%Die Terminals werden als Struktur dargestellt, 

\subsection{In und Outs}\label{subsec:impl_in_und_outs}
Die In und Outs werden mit den Scramblern als Knoten in einem Graphen dargestellt.
%TODO check
Die Knoten haben Zeiger auf weitere Knoten, die bei dem analogen Original mit dem Out-Kontakt verbunden wären.
Die In und Outs sind jeweils wieder Zeiger auf Terminal Kontakte.
Die Scrambler permutieren die aktiven Kontakte des In-Kontakts.

\subsection{Diagonalbrett}\label{subsec:impl_diagonal_board}
Das Diagonalbrett als native Datenstruktur darzustellen, hat sich als ein eher schlechter Einfall herausgestellt.
Eine Möglichkeit das Verhalten mit einer Datenstruktur zu imitieren, ist es, die einzelne Kontakte der Terminals als Vektor mit Zeiger auf Booleschen Werten abzubilden.
Hierbei Zeigen zum Beispiel der \emph{a}-Kontakt des \emph{B}-Terminals und der \emph{b}-Kontakt des \emph{A}-Terminals auf den gleichen Booleschen Wert.
Somit ist die Verbindung $A \Leftrightarrow B$ abgebildet.
Jedoch wäre es hier abermals nötig, den gesamten Vektor zu traversieren, um die aktiven Kontakte herauszufinden.
Die entsprechenden Kontakte müssten nun wieder einen normalen Vektor besitzen, in dem die aktiven Kontakte \glqq dicht\grqq{} stehen, damit die Scrambler effektiv arbeiten können, was keine wirklichen Ersparnisse bringen würde.

Aus diesem Grund wurde die Funktion des Diagonalbrettes in einer Funktion gekapselt:

\noindent
\lstinputlisting[style=mystyle, caption={Realisierung des Diagonalbrettes}, label={lst:code_impl_diag_board}]{Implementierung/diag_method.c}

Diese Funktion erhält drei Argumente: Einen Zeiger auf eine Turing Bombe und zwei Integer, die repräsentativ für die beiden Buchstaben der Kontakte stehen, die aktiviert werden sollen.


\subsection{Commons}\label{subsec:impl_commons}
Aufgrund der Einfachheit wurden die Commons in dieser Software-Implementation \glqq weg abstrahiert\grqq.
Diese wurden durch Zeiger auf den gleichen Kontakt ersetzt.
Die Anzahl der Kontakte pro Commons und die Gesamtzahl der verwendeten Commons wurde gezählt, sodass diese nicht die Anzahl des analogen Originals überschreiten.

\section{Algorithmus der Implementation}\label{sec:algorithm_bombe}
Im Gegensatz zur \glqq echten\grqq{} Bombe, welche eine Steckerbrett-Hypothese für die jeweils 17576 Walzenstellungen einer Walzenlage testete, testet die Software-Nachbildung eine Hypothese für alle Walzenstellungen der 60 möglichen Walzenlagen.
Eine modifizierte Breitensuche traversiert die Knoten des aufgespannten Graphen der \glqq Scrambler-Knoten\grqq.
%TODO lookup table for scrambler knoten.
Da es aufgrund den Tupel-Kombinationen nicht genügt, einen Knoten nur einmal zu besuchen und das Diagonalbrett es unmöglich macht, die Datenstruktur der Knoten linear zur durchlaufen, wird erneut eine \glqq Nachschlagetabelle\grqq{} benötigt.
Diese Nachschlagetabelle speichert die Knoten, bei denen der jeweilige In-Kontakt mit dem jeweiligen Terminal verbunden ist.
Zuerst werden alle Scrambler-Knoten von dem Test-Register aus in die Warteschlange der Breitensuche eingereiht, und danach alle Knoten die in einem Terminal anliegen, welches durch direkte Permutation oder durch das Diagonalbrett aktiviert wurden.
Wird durch die Permutation durch einen Scrambler in dem Out-Kontakt kein neuer Kontakt aktiv, wird dieser Knoten als \glqq besucht\grqq{} gekennzeichnet und nicht mehr in die Warteschlange eingereiht.
Ist die Warteschlange leer, sind alle Permutationen abgeschlossen und das Test-Register wird überprüft.



%In Pseudocode könnte man den Algorithmus der Bombe so darstellen:
%\begin{algorithm}[htbp]
%	\caption{Bombe Algorithmus}
%	\begin{algorithmic}
%			\Procedure{Bombe}{$p_0 \dots p_{n-1} :$ [Char], $c_0 \dots c_{n-1} :$ [Char]}
%			\ForAll{\textsl{rotors} $\in$ \textbf{permut(rotor order)}, \textsl{pos} $\in$ \textbf{[AAA $\dots$ ZZZ]}}
%			\State plugs: Char $\rightarrow \{ $Char$\}$
%			\State plugs$(p_0)\ \cup= \{\textbf{'A'}\}$
%			\While{\textsl{plugs} changing}
%			\ForAll{\textsl{i} $\in$ \textbf{[0\dots n--1]}}
%			\State plugs($c_i$) $\cup=$ $\bigcup_{p \in \text{plugs}(p_i)}$ encrypt(\textsl{rotors, p, pos}+\textsl{i})
%			\State plugs($p_i$) $\cup=$ $\bigcup_{p \in \text{plugs}(c_i)}$ encrypt(\textsl{rotors, p, pos}+\textsl{i})
%			\EndFor
%			\EndWhile
%			\If{$\forall$ \textsl{S} $\in$ \textbf{cod(plugs)}: \#S < \#Char}
%			\State report(\textsl{pos, plugs})
%			\EndIf
%			\EndFor
%			\EndProcedure
%		\end{algorithmic}
%	\label{alg:algorithm}
%\end{algorithm}



\chapter{Geschwindigkeit der Software-Nachbildung im Kontext}\label{ch:speed}